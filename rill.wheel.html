<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><link href="css/default.css" rel="stylesheet" type="text/css" /><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>rill.wheel documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Wheel</span> <span class="project-version">0.1.12</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="01-outline.html"><div class="inner"><span>Conceptual Overview</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rill</span></div></div></li><li class="depth-2 current"><a href="rill.wheel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>wheel</span></div></a></li><li class="depth-3 branch"><a href="rill.wheel.bare-repository.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bare-repository</span></div></a></li><li class="depth-3 branch"><a href="rill.wheel.caching-repository.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>caching-repository</span></div></a></li><li class="depth-3 branch"><a href="rill.wheel.report.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>report</span></div></a></li><li class="depth-3 branch"><a href="rill.wheel.repository.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>repository</span></div></a></li><li class="depth-3 branch"><a href="rill.wheel.testing.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>testing</span></div></a></li><li class="depth-3"><a href="rill.wheel.wrap-stream-properties.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>wrap-stream-properties</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="rill.wheel.html#var-aggregate"><div class="inner"><span>aggregate</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-aggregate.3F"><div class="inner"><span>aggregate?</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-apply-command"><div class="inner"><span>apply-command</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-apply-event"><div class="inner"><span>apply-event</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-apply-new-event"><div class="inner"><span>apply-new-event</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-apply-stored-event"><div class="inner"><span>apply-stored-event</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-commit.21"><div class="inner"><span>commit!</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-conflict"><div class="inner"><span>conflict</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-conflict.3F"><div class="inner"><span>conflict?</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-defaggregate"><div class="inner"><span>defaggregate</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-defcommand"><div class="inner"><span>defcommand</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-defevent"><div class="inner"><span>defevent</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-empty"><div class="inner"><span>empty</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-empty.3F"><div class="inner"><span>empty?</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-exists"><div class="inner"><span>exists</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-fetch-aggregate"><div class="inner"><span>fetch-aggregate</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-merge-aggregate-props"><div class="inner"><span>merge-aggregate-props</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-new-events"><div class="inner"><span>new-events</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-new.3F"><div class="inner"><span>new?</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-ok"><div class="inner"><span>ok</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-ok.3F"><div class="inner"><span>ok?</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-reason"><div class="inner"><span>reason</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-rejection"><div class="inner"><span>rejection</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-rejection.3F"><div class="inner"><span>rejection?</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-repository"><div class="inner"><span>repository</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-transact.21"><div class="inner"><span>transact!</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-type"><div class="inner"><span>type</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-type-properties"><div class="inner"><span>type-properties</span></div></a></li><li class="depth-1"><a href="rill.wheel.html#var-uncommitted.3F"><div class="inner"><span>uncommitted?</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">rill.wheel</h1><div class="doc"><div class="markdown"><h1><a href="#aggregates-and-events" name="aggregates-and-events"></a>Aggregates and Events</h1>
<h3><a href="#synopsis" name="synopsis"></a>Synopsis</h3>
<pre><code>(require '[rill.wheel :as aggregate
           :refer [defaggregate defevent]])

(defaggregate user
  "a user is identified by a single `email` property"
  [email])

(defevent registered ::user
  "user was correctly registered"
  [user]
  (assoc user :registered? true))

(defevent unregistered ::user
  "user has unregistered"
  [user]
  (dissoc user :registered?))

(-&gt; (user "user@example.com") registered :registered?)
  =&gt; true

(registered-event (user "user@example.com"))
  =&gt; {:rill.message/type :user/registered,
      :email "user@example.com",
      :rill.wheel/type :user/user}

(wheel/new-events some-aggreate)
  =&gt; seq-of-events
</code></pre>
<h3><a href="#store-and-retrieve-aggregates-in-a-repository" name="store-and-retrieve-aggregates-in-a-repository"></a>Store and retrieve aggregates in a repository</h3>
<pre><code>(-&gt; (get-user repo "user@example.com)
    (registered)
    (command/commit!))
;; ...
(get-user some-repository "user@example.com")
</code></pre>
<h3><a href="#full-example-of-defaggregate" name="full-example-of-defaggregate"></a>Full example of defaggregate</h3>
<pre><code>(defaggregate turnstile
  "An aggregate with docstring"
  [turnstile-id]
  {:pre [(instance? java.util.UUID turnstile-id)]}
  ((installed
    "A turnstile was installed"
    [turnstile]
    (assoc turnstile
           :installed? true
           :locked? true
           :coins 0
           :turns 0
           :pushes 0))

   (coin-inserted
    "A Coin was inserted into the turnstile"
    [turnstile]
    (-&gt; turnstile
        (update :coins inc)
        (assoc :locked? false)))

   (arm-turned
    "The turnstile's arm was turned"
    [turnstile]
    (-&gt; turnstile
        (update :pushes inc)
        (update :turns inc)
        (assoc :locked? true)))

   (arm-pushed-ineffectively
    "The arm was pushed but did not move"
    [turnstile]
    (-&gt; turnstile
        (update :pushes inc))))

  ((install-turnstile
    [repo turnstile-id]
    (let [turnstile (get-turnstile repo turnstile-id)]
      (if (wheel/exists turnstile)
        (rejection turnstile "Already exists")
        (installed turnstile))))

   (insert-coin
    "Insert coin into turnstile, will unlock"
    [repo turnstile-id]
    (let [turnstile (get-turnstile repo turnstile-id)]
      (if (:installed? turnstile)
        (coin-inserted turnstile)
        (rejection turnstile "Turnstile not installed"))))

   (push-arm
    "Push the arm, might turn or be ineffective"
    {::wheel/events [::arm-pushed-ineffectively ::arm-turned]}
    [repo turnstile-id]
    (let [turnstile (get-turnstile repo turnstile-id)]
      (cond
        (not (:installed? turnstile))
        (rejection turnstile "Not installed")
        (:locked? turnstile)
        (arm-pushed-ineffectively turnstile)
        :else
         (arm-turned turnstile))))))
</code></pre>
<h1><a href="#commands" name="commands"></a>Commands</h1>
<p>Commands are functions that apply new events to aggregates.</p>
<h2><a href="#command-flow" name="command-flow"></a>Command flow</h2>
<pre><code> (-&gt; (get-some-aggregate repository id) ; 1.
     (cmd-call additional-argument)     ; 2.
     (commit!))                         ; 3.
</code></pre>
<h3><a href="#1-fetch-aggregate" name="1-fetch-aggregate"></a>1. Fetch aggregate</h3>
<p>Before calling the command, the aggregate it applies to should get fetched from the <code>repository</code>. In rill/wheel, this will always work and must be done even for aggregates that have no events applied to them - this will result in an <code>rill.wheel/empty?</code> aggregate that can be committed later.</p>
<h3><a href="#2-calling-the-command" name="2-calling-the-command"></a>2. Calling the command</h3>
<p>A command can have any number of arguments, and it’s idiomatic for commands to take the aggregate-to-change as the first argument.</p>
<p>As a matter of style, it’s suggested that commands do not fetch other objects from the repostory but are explicitly passed any necessary aggregates.</p>
<h4><a href="#success" name="success"></a>Success</h4>
<p>A successful command returns an <code>uncomitted?</code> aggregate.</p>
<h4><a href="#rejection" name="rejection"></a>Rejection</h4>
<p>A command may be rejected, in which case the command returns a <code>rejection</code> - meaning the request was denied for business reasons. Rejections are explicitly constructed in the <code>defcommand</code> body by the application writer.</p>
<p>It’s typically useless to retry a rejected command.</p>
<h3><a href="#3-committing-results" name="3-committing-results"></a>3. Committing results</h3>
<p>The result of a command can be persisted back to the repository by calling <code>commit!</code>. If <code>commit!</code> is passed a <code>rejection</code> it will return it. Otherwise the argument should be an aggregate that will be persisted.</p>
<h3><a href="#ok" name="ok"></a>ok</h3>
<p>A successful commit returns an <code>ok?</code> object describing the committed events and aggregate.</p>
<h3><a href="#conflict" name="conflict"></a>conflict</h3>
<p>Commiting an updated aggregate can return a <code>conflict</code>, meaning there were changes to the aggregate in the repository in the time between fetching the aggregate and calling <code>commit!</code>.</p>
<p>Depending on the use case, it may be useful to update the aggregate and retry a conflicted command.</p>
<h2><a href="#defining-commands" name="defining-commands"></a>Defining commands</h2>
<pre><code> (defaggregate x                                 ; 1.
   [id])

 (defevent x-happened                            ; 2.
    "X happened to obj"
    [obj arg1]
    (assoc obj :a arg1))

 (defcommand do-x ::x                            ; 3.
    "Make X happen to obj"
    [obj arg1]
    (if (= (:a obj) arg1))                       ; 4.
        (rejection obj "Arg already applied")
        (x-happened obj)))                       ; 5.
</code></pre>
<h3><a href="#1-define-the-aggregate-type" name="1-define-the-aggregate-type"></a>1. Define the aggregate type</h3>
<h3><a href="#2-define-events-to-apply" name="2-define-events-to-apply"></a>2. Define events to apply</h3>
<p>Commands can only affect aggregates by applying events to them. Here we define an event with <code>defevent</code>. When the <code>x-happened</code> event is applied it will set key <code>:a</code> of aggregate <code>obj</code>.</p>
<p>It’s idiomatic to give events a past-tense name, to indicate that the event happened and is not .</p>
<h3><a href="#3-define-command" name="3-define-command"></a>3. Define command</h3>
<p>Commands are defined by calling <code>defcommand</code>, specifying a name, aggregate type, optional docstring, argument vector and a command body.</p>
<h3><a href="#4-test-state-and-reject-command" name="4-test-state-and-reject-command"></a>4. Test state and reject command</h3>
<p>Aggregate state is typically only used to keep track of information that must be used to validate commands. When a command must not proceed, the command body can return a <code>rejection</code> with a reason.</p>
<h3><a href="#5-apply-new-event-s-" name="5-apply-new-event-s-"></a>5. Apply new event(s)</h3>
<p>When the command is acceptable, it should apply the necessary events to the aggregate and return the result (the updated aggregate).</p>
<h2><a href="#alternative-command-invocations" name="alternative-command-invocations"></a>Alternative command invocations</h2>
<p><code>defcommand</code> installs a number of functions and multi-methods that can be used to invoke the defined command.</p>
<p>In the following examples, we assume the following definitions:</p>
<pre><code> (ns user
    (:require [rill.wheel :as aggregate
                                    :refer [defaggregate
                                            defcommand
                                            defevent
                                            transact!
                                            ok?]]))

 (defaggregate user
    [user-id])

 (defevent registered ::user
    [user name])

 (defcommand register ::user
    [user name]
    (registered user name))
</code></pre>
<h3><a href="#commands-as-data" name="commands-as-data"></a>Commands as data</h3>
<p>If you need to, you can describe and execute any command defined with <code>defcommand</code> as a message. The commands are implemented as maps with a <code>rill.message/type</code> key indicating the command type with a qualified keyword.</p>
<h4><a href="#command-constructor" name="command-constructor"></a>Command constructor</h4>
<p>For every <code>(defcommand cmd-name ...)</code> definition, a constructor function named <code>cmd-name-command</code> is created that will create a valid rill.wheel command message:</p>
<pre><code>(register-command "my-id" "Some Name")

=&gt; {:rill.message/type :user/register,
    :user-id "my-id",
    :name "Some Name"}
</code></pre>
<p>Note that the register-command function also takes the identifying properties of the <code>user</code> aggregate. This is required so that the correct <code>user</code> aggregate can be fetched from the repository.</p>
<h4><code>transact!</code></h4>
<p>You can run the given command message directly into the repository using <code>transact!</code>. This will fetch the aggregate using the installed <code>fetch-aggregate</code> multi-method, calls <code>apply-command</code> and <code>commit!</code> the result.</p>
<pre><code>(ok? (transact! repository
                (register-command "my-id"
                                  "Some Name")))

=&gt; true
</code></pre>
<p>If your commands are invoked from some remote source (like a single-page application - see the <code>mpare-net/weir</code> project), these are the semantics you probably want (excluding authentication etc).</p>
<h4><code>apply-command</code></h4>
<p>The apply-command is used by <code>transact!</code> and takes the aggregate to update and the command message and executes the <code>defcommand</code> body.</p>
<pre><code> (-&gt; (get-user repo my-id)
     (apply-command (register-command my-id my-name)))
</code></pre>
<h4><code>fetch-aggregate</code></h4>
<p>Also used by <code>transact!</code>, this method takes the repository and the command message and returns the aggregate the command should be applied to.</p>
<h3><a href="#commands-as-functions" name="commands-as-functions"></a>Commands as functions</h3>
<p>It’s convenient to be able to call commands directly as regular names functions. For this purpose there are two flavors:</p>
<h4><code>command-name!</code></h4>
<p>A generated function named after the command with an exclamation mark added. Takes the repository and all arguments to identify the aggregate and other command options, and commits the result.</p>
<pre><code> (ok? (register! repository "user-id" "Some Name"))

 =&gt; true
</code></pre>
<h4><code>command-name</code></h4>
<p>Another generated function that takes the aggregate as the first argument and the additional command arguments and applies the command to the aggregate. This does not commit and returns the updated aggregate or a a rejection. You can chain successful calls to named command functions and <code>commit!</code> the result.</p>
<pre><code> (ok? (-&gt; repository
        (get-user "user-id")
        (register "Some Name")
        (commit!)))

 =&gt; true
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See also</h2>
<ul>
  <li><code>rill.event-store</code></li>
</ul></div></div><div class="public anchor" id="var-aggregate"><h3>aggregate</h3><div class="usage"><code>(aggregate result)</code></div><div class="doc"><div class="markdown"><p>Return the aggregate from a result. If the result <em>is</em> an aggregate, returns it as is.</p></div></div></div><div class="public anchor" id="var-aggregate.3F"><h3>aggregate?</h3><div class="usage"><code>(aggregate? obj)</code></div><div class="doc"><div class="markdown"><p>Test that <code>obj</code> is an aggregate</p></div></div></div><div class="public anchor" id="var-apply-command"><h3>apply-command</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Given a command and aggregate, apply the command to the aggregate. Should return an updated aggregate or a rejection</p></div></div></div><div class="public anchor" id="var-apply-event"><h3>apply-event</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Update the properties of <code>aggregate</code> given <code>event</code>. Implementation for different event types will be given by <code>defevent</code></p></div></div></div><div class="public anchor" id="var-apply-new-event"><h3>apply-new-event</h3><div class="usage"><code>(apply-new-event aggregate event)</code></div><div class="doc"><div class="markdown"><p>Apply a new event to the aggregate. The new events will be committed when the aggregate is committed to a repository.</p></div></div></div><div class="public anchor" id="var-apply-stored-event"><h3>apply-stored-event</h3><div class="usage"><code>(apply-stored-event aggregate event)</code></div><div class="doc"><div class="markdown"><p>Apply a previously committed event to the aggregate. This increments the version of the aggregate.</p></div></div></div><div class="public anchor" id="var-commit.21"><h3>commit!</h3><div class="usage"><code>(commit! aggregate-or-rejection)</code></div><div class="doc"><div class="markdown"><p>Commit the result of a command execution. If the command returned a <code>rejection</code> nothing is committed and the rejection is returned. If the result is an aggregate it is committed to the repository. If that succeeds an <code>ok</code> is returned. Otherwise a <code>conflict</code> is returned.</p></div></div></div><div class="public anchor" id="var-conflict"><h3>conflict</h3><div class="usage"><code>(conflict aggregate)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-conflict.3F"><h3>conflict?</h3><div class="usage"><code>(conflict? result)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-defaggregate"><h3>defaggregate</h3><h4 class="type">macro</h4><div class="usage"><code>(defaggregate name doc-string? attr-map? [properties*] pre-post-map? events? commands?)</code></div><div class="doc"><div class="markdown"><p>Defines an aggregate type, and aggregate-id function. The aggregate’s id key is a map with a key for every property in <code>properties*</code>, plus the aggregate type, a qualified keyword from <code>name</code>.</p>
<p>Also defines a function <code>get-{name}</code>, which takes an additional first repository argument and retrieves the aggregate.</p>
<p>events? and commands? are sequences of event specs and command specs and passed to <code>defevent</code> and <code>rill.wheel/defcommand</code> respectively.</p></div></div></div><div class="public anchor" id="var-defcommand"><h3>defcommand</h3><h4 class="type">macro</h4><div class="usage"><code>(defcommand name aggregate-type doc-string? attr-map? [repository properties*] pre-post-map? body)</code></div><div class="doc"><div class="markdown"><p>Defines a command as a named function that takes any arguments and returns an <code>aggregate</code> or <code>rejection</code> that can be passed to <code>commit!</code>.</p>
<p>The metadata of the command may contain a <code>:rill.wheel/events</code> key, which will specify the types of the events that may be generated. As a convenience, the corresponding event functions are <code>declare</code>d automatically so the <code>defevent</code> statements can be written after the command. This usually reads a bit nicer.</p>
<pre><code> (defcommand answer-question ::question
   "Try to answer a question"
   [question user-id answer]
   (if (some-check question answer)
     (answered-correctly question user-id answer)
     (answered-incorrectly question user-id answer)))
</code></pre></div></div></div><div class="public anchor" id="var-defevent"><h3>defevent</h3><h4 class="type">macro</h4><div class="usage"><code>(defevent name aggregate-type doc-string? attr-map? [aggregate properties*] pre-post-map? body*)</code></div><div class="doc"><div class="markdown"><p>Defines function that takes aggregate + properties, constructs an event and applies the event as a new event to aggregate. Properties defined on the <code>aggregate-type</code> definition will be merged with the event; do not define properties with <code>defevent</code> that are already defined in the corresponding <code>defaggregate</code>.</p>
<p>For cases where you only need the event and can ignore the aggregate, the function “{name}-event” is defined with the same signature. This function is used by the “{name}” function to generate the event befor calling <code>apply-event</code> (see below).</p>
<p>The given <code>prepost-map</code>, if supplied gets included in the definiton of the “{name}-event” function.</p>
<p>The given <code>body</code>, if supplied, defines an <code>apply-event</code> multimethod that applies the event to the aggregate. If no <code>body</code> is supplied, the default <code>apply-event</code> will be used, which will return the aggregate as is.</p></div></div></div><div class="public anchor" id="var-empty"><h3>empty</h3><div class="usage"><code>(empty aggregate-id)</code></div><div class="doc"><div class="markdown"><p>Create a new aggregate with id <code>aggregate-id</code> and no events. Aggregate version will be -1. Note that empty aggregates cannot be stored.</p></div></div></div><div class="public anchor" id="var-empty.3F"><h3>empty?</h3><div class="usage"><code>(empty? aggregate)</code></div><div class="doc"><div class="markdown"><p>Test that the aggregate is new and has no uncommitted events</p></div></div></div><div class="public anchor" id="var-exists"><h3>exists</h3><div class="usage"><code>(exists aggregate)</code></div><div class="doc"><div class="markdown"><p>If aggregate is not new, return aggregate, otherwise nil</p></div></div></div><div class="public anchor" id="var-fetch-aggregate"><h3>fetch-aggregate</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Given a command and repository, fetch the target aggregate</p></div></div></div><div class="public anchor" id="var-merge-aggregate-props"><h3>merge-aggregate-props</h3><div class="usage"><code>(merge-aggregate-props aggregate partial-event)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-new-events"><h3>new-events</h3><div class="usage"><code>(new-events aggregate)</code></div><div class="doc"><div class="markdown"><p>The events that will be committed when this aggregate is committed.</p></div></div></div><div class="public anchor" id="var-new.3F"><h3>new?</h3><div class="usage"><code>(new? aggregate)</code></div><div class="doc"><div class="markdown"><p>Test that the aggregate has no committed events.</p></div></div></div><div class="public anchor" id="var-ok"><h3>ok</h3><div class="usage"><code>(ok aggregate)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-ok.3F"><h3>ok?</h3><div class="usage"><code>(ok? result)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-reason"><h3>reason</h3><div class="usage"><code>(reason rejection)</code></div><div class="doc"><div class="markdown"><p>Return the reason for a <code>rejection</code>. Returns <code>:rill.wheel/conflict</code> for a conflict.</p></div></div></div><div class="public anchor" id="var-rejection"><h3>rejection</h3><div class="usage"><code>(rejection aggregate reason)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-rejection.3F"><h3>rejection?</h3><div class="usage"><code>(rejection? result)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-repository"><h3>repository</h3><div class="usage"><code>(repository aggregate)</code></div><div class="doc"><div class="markdown"><p>Return the repository of <code>aggregate</code>.</p></div></div></div><div class="public anchor" id="var-transact.21"><h3>transact!</h3><div class="usage"><code>(transact! repo command)</code></div><div class="doc"><div class="markdown"><p>Run and commit the given command against the repository</p></div></div></div><div class="public anchor" id="var-type"><h3>type</h3><div class="usage"><code>(type aggregate)</code></div><div class="doc"><div class="markdown"><p>Return the type of this aggregate</p></div></div></div><div class="public anchor" id="var-type-properties"><h3>type-properties</h3><div class="usage"><code>(type-properties t)</code></div><div class="doc"><div class="markdown"><p>the properties of the identifier of aggreate type <code>t</code></p></div></div></div><div class="public anchor" id="var-uncommitted.3F"><h3>uncommitted?</h3><div class="usage"><code>(uncommitted? aggregate)</code></div><div class="doc"><div class="markdown"><p><code>aggregate</code> has events applied that can be committed.</p></div></div></div></div></body></html>